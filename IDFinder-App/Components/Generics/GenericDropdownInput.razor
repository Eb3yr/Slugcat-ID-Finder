@typeparam T
<li>
	<div style="display: flex; align-items: center; padding: 0px; font-size: @(FontSize)px" >
		<select TValue="T" @attributes="AdditionalAttributes">
			@foreach (T o in Options)
			{
				<option value="@o" onclick="@(() => Change(o))">	<!-- binding to select causes all sorts of weird behaviours, so we use this workaround. -->
					@o
				</option>
			}
		</select>
		<WeightBox @bind-Weight="Weight" @bind-Weight:after="InvokeChanged" FontSize="FontSize" />
	</div
</li>

@code {
	[Parameter]
	public T SelectedOption { get; set; }
	[Parameter]
	public IEnumerable<T> Options { get; set; }
	[Parameter]
	public float Weight { get; set; } = 0f;
	[Parameter]
	public string WeightLabel { get; set; } = Consts.DefWeightLabel;
	[Parameter]
	public float FontSize { get; set; } = Consts.DefFontSize;
	[Parameter]
	public EventCallback<(T target, float weight)> SelectedOptionChanged { get; set; }
	[Parameter(CaptureUnmatchedValues = true)]
	public IDictionary<string, object>? AdditionalAttributes { get; set; }

	protected override void OnInitialized()
	{

		// I should probably make the weight number input adapt to its contents' width, like I did with the precise input in SliderInput.razor

		if (Options is null || Options.Count() == 0)
		{
			if (!typeof(T).IsEnum)
				throw new ArgumentNullException();

			Options = Enum.GetValues(typeof(T)).Cast<T>();
			SelectedOption = Options.ElementAt(0);
		}

		if (SelectedOption is null)
			SelectedOption = Options.ElementAt(0);
	}
	private void Change(T t)
	{
		SelectedOption = t;
		InvokeChanged();
	}
	private void InvokeChanged()
	{
		SelectedOptionChanged.InvokeAsync((SelectedOption, Weight));
	}
}