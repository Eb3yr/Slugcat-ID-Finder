@using IDFinder_App.Components
@using IDFinder

@page "/"
<style>
	body {
		background-color: #777;
	}
</style>

<!-- TODO: Rename event callbacks to fit "OnChanged" kinda structure. Do it before I put all the components in here and have to manually edit them. -->

<StrDropdown Options="@(new List<string>(){ "A", "B", "C" })" SelectedOptionChanged="@(((string s, float w) t) => Console.WriteLine("Selected changed to " + t.s))" />

<EnumDropdown T="MyEnum" SelectedOptionChanged="@(((MyEnum e, float w) t) => Console.WriteLine("Selected enum changed to " + t.e + " and type of e is " + t.e.GetType()))" />

<SliderInput TValue="float" />


<ul style="list-style-type:none">
	<ListElement Label="Scug" InitialValue="CheckedScug" CheckboxStateChanged="(bool b) => CheckedScug = b" Foldered="FolderScug" FolderedChanged="(bool b) => FolderScug = b" />
	@if (!FolderScug)
	{
		<li><ul>

		<ListElement Label="Personality" InitialValue="CheckedPersonality" CheckboxStateChanged="(bool b) => CheckedPersonality = b" Foldered="FolderPersonality" FolderedChanged="(bool b) =>      FolderPersonality = b" />
		@if (!FolderPersonality)
		{
		<li>
			<ul>
				<SliderInput TValue="float" Target="personalityParams.Sympathy.Value.target" InputChanged="@(((float, float) t) => personalityParams.Sympathy = t)" />
				<SliderInput TValue="float" Target="personalityParams.Energy.Value.target" InputChanged="@(((float, float) t) => personalityParams.Energy = t)" />
				<SliderInput TValue="float" Target="personalityParams.Bravery.Value.target" InputChanged="@(((float, float) t) => personalityParams.Bravery = t)" />
				<SliderInput TValue="float" Target="personalityParams.Nervous.Value.target" InputChanged="@(((float, float) t) => personalityParams.Nervous = t)" />
				<SliderInput TValue="float" Target="personalityParams.Aggression.Value.target" InputChanged="@(((float, float) t) => personalityParams.Aggression = t)" />
				<SliderInput TValue="float" Target="personalityParams.Dominance.Value.target" InputChanged="@(((float, float) t) => personalityParams.Dominance = t)" /> 
			</ul>
		</li>
		}

		<ListElement Label="NPCStats" InitialValue="CheckedNPCStats" CheckboxStateChanged="(bool b) => CheckedNPCStats = b" Foldered="FolderNPCStats" FolderedChanged="(bool b) => FolderNPCStats = b" />
		@if (!FolderNPCStats)
		{
		<li>
			<ul>
			</ul>
		</li>
		}

		<ListElement Label="SlugcatStats" InitialValue="CheckedSlugcatStats" CheckboxStateChanged="(bool b) => CheckedSlugcatStats = b" Foldered="FolderSlugcatStats" FolderedChanged="(bool b) => FolderSlugcatStats = b" />
		@if (!FolderSlugcatStats)
		{
		<li>
			<ul>
			</ul>
		</li>
		}

		<ListElement Label="FoodPrefs" InitialValue="CheckedFoodPrefs" CheckboxStateChanged="(bool b) => CheckedFoodPrefs = b" Foldered="FolderFoodPrefs" FolderedChanged="(bool b) => FolderFoodPrefs = b" />
		@if (!FolderFoodPrefs)
		{
		<li>
			<ul>
			</ul>
		</li>
		}

		</ul></li>
	}

	<ListElement Label="Scav" InitialValue="CheckedScav" CheckboxStateChanged="(bool b) => CheckedScav = b" Foldered="FolderScav" FolderedChanged="(bool b) => FolderScav = b" />
	@if (!FolderScav)
	{
		<li><ul>

		<ListElement Label="IVars" InitialValue="CheckedIVars" CheckboxStateChanged="(bool b) => CheckedIVars = b" Foldered="FolderIVars" FolderedChanged="(bool b) => FolderIVars = b" />
		@if (!FolderIVars)
		{
			<li>
				<ul>
				</ul>
			</li>
		}

		<ListElement Label="ScavColors" InitialValue="CheckedScavColors" CheckboxStateChanged="(bool b) => CheckedScavColors = b" Foldered="FolderScavColors" FolderedChanged="(bool b) => FolderScavColors = b" />
		@if (!FolderScavColors)
		{
			<li>
				<ul>
				</ul>
			</li>
		}

		<ListElement Label="ScavSkills" InitialValue="CheckedScavSkills" CheckboxStateChanged="(bool b) => CheckedScavSkills = b" Foldered="FolderScavSkills" FolderedChanged="(bool b) => FolderScavSkills = b" />
		@if (!FolderScavSkills)
		{
			<li>
				<ul>
				</ul>
			</li>
		}

		<ListElement Label="ScavBack" InitialValue="CheckedScavBack" CheckboxStateChanged="(bool b) => CheckedScavBack = b" Foldered="FolderScavBack" FolderedChanged="(bool b) => FolderScavBack = b" />
		@if (!FolderScavBack)
		{
			<li>
				<ul>
				</ul>
			</li>
		}

		</ul></li>
	}
</ul>

<span>
	<button @onclick="PrintSearchResults">Initiate search</button>
	@if (isCurrentlySearching)
	{
		<button @onclick="@(() => Console.WriteLine("abortplaceholder"))">Abort</button>
	}
</span>

<button @onclick="@(() => {Console.WriteLine("Click!"); responsiveCounter++;})">Press me to test responsiveness. Counter: @responsiveCounter</button>

<button @onclick="PrintPersonality">Print out IPersonalityParams</button>

@code
{

	private void PrintPersonality()
	{
		Console.WriteLine($"personalityParams.Sympathy = {personalityParams.Sympathy}");
		Console.WriteLine($"personalityParams.Energy = {personalityParams.Energy}");
		Console.WriteLine($"personalityParams.Bravery = {personalityParams.Bravery}");
		Console.WriteLine($"personalityParams.Nervous = {personalityParams.Nervous}");
		Console.WriteLine($"personalityParams.Aggression = {personalityParams.Aggression}");
		Console.WriteLine($"personalityParams.Dominance = {personalityParams.Dominance}");
	}
	// Rain World UI isn't too complicated. Thin lines, curved edge rectangles, double bezel on the selected button, and a font. I can find recreations of the font on fontstruct.com
	// Then it's just about sizing, aligning, and a decent background.

	bool _cs = false;
	bool isCurrentlySearching
	{
		get => _cs;
		set
		{
			Console.WriteLine(value + " searching");
			_cs = value;
		}
	}
	int responsiveCounter = 0;

	bool FolderScug = true;
	bool FolderScav = true;

	bool CheckedScug = false;
	bool CheckedScav = false;

	bool FolderPersonality = true;
	bool FolderNPCStats = true;
	bool FolderSlugcatStats = true;
	bool FolderFoodPrefs = true;
	bool FolderIVars = true;
	bool FolderScavColors = true;
	bool FolderScavSkills = true;
	bool FolderScavBack = true;

	bool CheckedPersonality = false;
	bool CheckedNPCStats = false;
	bool CheckedSlugcatStats = false;
	bool CheckedFoodPrefs = false;
	bool CheckedIVars = false;
	bool CheckedScavColors = false;
	bool CheckedScavSkills = false;
	bool CheckedScavBack = false;

	// When formulating the SearchParams to send to the Searcher (Yes, do this whenever search is called, don't track it, it's a cheap computation and makes things easier), I need to consider what's checked or not. 

	IPersonalityParams personalityParams;
	INPCStatsParams nPCStatsParams;
	ISlugcatStatsParams slugcatStatsParams;
	IFoodPreferencesParams foodPreferencesParams;
	IIndividualVariationsParams individualVariationsParams;
	IScavColorsParams scavColorsParams;
	IScavSkillsParams scavSkillsParams;
	IScavBackPatternsParams scavBackPatternsParams;

	public Index()
	{
		personalityParams = new SearchParams(false);
		nPCStatsParams = new SearchParams(false);
		slugcatStatsParams = new SearchParams(false);
		foodPreferencesParams = new SearchParams(false);
		individualVariationsParams = new SearchParams(false);
		scavColorsParams = new SearchParams(false);
		scavSkillsParams = new SearchParams(false);
		scavBackPatternsParams = new SearchParams(false);

		// default placeholder val
		personalityParams = new SearchParams()
			{
				Aggression = (1f, 1f)
			};
	}

	private async void PrintSearchResults()
	{
		// TODO: Set up a cancellation token system in these two methods to abort the previous search if the abort button is pressed
		// Will want an abort button that shows up only when a search is active, tracked by a bool.
		// Can do that with Thread.Abort

		// TODO: Do this properly. Doesn't work. Read a tutorial

		isCurrentlySearching = true;
		//new Task(() =>
		//{
		//	foreach (var kvp in InitiateSearch().Result)
		//		Console.WriteLine("kvp: " + kvp.Value + "," + kvp.Key);
		//}).WaitAsync(CancellationToken.None).Start();
		//
		//Thread thread = new Thread(new ThreadStart(() =>
		//{
		//	foreach (var kvp in InitiateSearch().Result)
		//		Console.WriteLine("kvp: " + kvp.Value + "," + kvp.Key);
		//})).Start();

		await Task.Run(() =>
		{
			foreach (var kvp in InitiateSearch().Result)
				Console.WriteLine("kvp: " + kvp.Value + "," + kvp.Key);

			isCurrentlySearching = false;
		});
	}

	private async Task<IEnumerable<KeyValuePair<float, int>>> InitiateSearch()
	{
		// Compose it all into a search param, add up, call Search.
		SearchParams sParams = (SearchParams)personalityParams + (SearchParams)nPCStatsParams + (SearchParams)slugcatStatsParams + (SearchParams)foodPreferencesParams + (SearchParams)individualVariationsParams + (SearchParams)scavColorsParams + (SearchParams)scavSkillsParams + (SearchParams)scavBackPatternsParams;

		// Placeholder vars
		int start = 0;
		int stop = 100_000_000;
		int numToStore = 24;
		int threads = 8;
		bool trimNumToStore = true;
		// Need to set up infrastructure for logging percents properly now.
		bool printToConsole = true;

		// New Task to run the search on without blocking this thread
		var task = new Task<IEnumerable<KeyValuePair<float, int>>>(() => Searcher.SearchThreaded(start, stop, numToStore, threads, sParams, trimNumToStore, printToConsole));
		task.Start();
		return await task;
	}



	MyEnum enumTracker = MyEnum.Zero;

	enum MyEnum
	{
		Zero,
		One,
		Two
	}
}